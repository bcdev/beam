Further development towards TrackPoints
=======================================

- Remove most calls to Placemark.createPointPlacemark():
  * Many of those calls copy placemarks from one VDN to another, although this will
    not be required anymore: we only need to copy VDN and their features. Then, placemarks
    will be created accordingly. This basically already implemented in
    ProductUtils.copyVectorData(source, target). Therefore we'll implement the capability
    of a VDN to create corresponding Placemarks whenever features are added.
    (Check: And vice versa?). Placemark collections will then stay in sync with feature
    collection. Also this is already implemented in PlacemarkGroup.
  * Analyse args of remaining calls: which are Pins, which GCPs, how general are these?
    e.g.: PointPlacemarkDescriptor.createPointPlacemark(<point-args>)
  * We don't store pins in DIMAP anymore, all placemarks will be stored in the same way.
- How will we import & export placemarks with respect to their underlying features.
  Will we only export features? No, this way we won't get all associated (sample) data
  for point placemarks.
- Action "Create new geometry container" --> "Create new feature collection" or
  "vector data node", users should also select feature type. BUT where do feature types
  come from? We have no registry. We have PlacemarkDescriptors. Shall users select
  from registered PlacemarkDescriptors? Then these must provide (default / basis) feature
  type. BUT then: How can they be responsible for (compatible with) more than one feature
  type?
    Possible idea: Every PlacemarkDescriptor produces a unique feature type and only features of
    exactly this type. Users must make a choice, when multiple PlacemarkDescriptors match the
    same feature type. This will happen when
    1. importing data (e.g. shapefiles)
    2. creating new vector data nodes (see "Create new geometry container")
    We might need something like dynamic features that are created for point features
    while bands are added or removed --> dynamic feature type (feature type extender, or
    "runtime feature type")
- When copying VDNs --> rename ones with same name that exist before
- Remove ProductProjectionBuilder but usage in MosaicProcessor: is it still required?
- Remove all redundant calls to PinDescriptor.getInstance()
- Remove all redundant calls to GcpDescriptor.getInstance()
- Remove VectorDataGroupTN.mustCount(), because there is later no need to differentiate
- Ease access from Figure (selection) to specific Placemarks + Features
- InsertPlacemarkInteractor --> InsertPointPlacemarkInteractor

- Discuss following roles
  * VectorDataNode:
    + feature type / placemark descriptor
    + collection of placemarks
  * Placemark (VectorDataItem)
    + placemark descriptor
    + feature

- Harmonise flat data table I/O
  - exported pin files
  - vector data node I/O
  - pixel extraction, PixBox
  - Calvalus in-situ data / pixel extraction
  - column naming: camel-case or underscore
  - copy to clipboard
  - Format:

    property-record        := '#'<property-name> '=' <property-value>
    attribute-header       := <attribute-name> [':'<attribute-type>]
    feature-format         := {<property-record> NL} <feature-type-record> {NL <feature-record>}
    simple-format          := {<property-record> NL} <header-record>       {NL <data-record>}
    feature-type-record    := '@'<feature-type-name> {TAB <attribute-header>}
    feature-record:        := <feature-id>           {TAB <attribute-value>}
    header-record          := <attribute-header> {TAB <attribute-header>}
    data-record:           := <attribute-value>  {TAB <attribute-value>}